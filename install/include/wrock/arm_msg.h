/* Software License Agreement (BSD License)
 *
 * Copyright (c) 2011, Willow Garage, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Willow Garage, Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * Auto-generated by genmsg_cpp from file /home/mike/catkin_ws/src/wrock/msg/arm_msg.msg
 *
 */


#ifndef WROCK_MESSAGE_ARM_MSG_H
#define WROCK_MESSAGE_ARM_MSG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace wrock
{
template <class ContainerAllocator>
struct arm_msg_
{
  typedef arm_msg_<ContainerAllocator> Type;

  arm_msg_()
    : j1(0.0)
    , j2(0.0)
    , j3(0.0)
    , j4(0.0)
    , j5(0.0)
    , j6(0.0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , rx(0.0)
    , ry(0.0)
    , rz(0.0)
    , vel(0.0)
    , acc(0.0)
    , pose(false)  {
    }
  arm_msg_(const ContainerAllocator& _alloc)
    : j1(0.0)
    , j2(0.0)
    , j3(0.0)
    , j4(0.0)
    , j5(0.0)
    , j6(0.0)
    , x(0.0)
    , y(0.0)
    , z(0.0)
    , rx(0.0)
    , ry(0.0)
    , rz(0.0)
    , vel(0.0)
    , acc(0.0)
    , pose(false)  {
    }



   typedef float _j1_type;
  _j1_type j1;

   typedef float _j2_type;
  _j2_type j2;

   typedef float _j3_type;
  _j3_type j3;

   typedef float _j4_type;
  _j4_type j4;

   typedef float _j5_type;
  _j5_type j5;

   typedef float _j6_type;
  _j6_type j6;

   typedef float _x_type;
  _x_type x;

   typedef float _y_type;
  _y_type y;

   typedef float _z_type;
  _z_type z;

   typedef float _rx_type;
  _rx_type rx;

   typedef float _ry_type;
  _ry_type ry;

   typedef float _rz_type;
  _rz_type rz;

   typedef float _vel_type;
  _vel_type vel;

   typedef float _acc_type;
  _acc_type acc;

   typedef uint8_t _pose_type;
  _pose_type pose;




  typedef boost::shared_ptr< ::wrock::arm_msg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::wrock::arm_msg_<ContainerAllocator> const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;

}; // struct arm_msg_

typedef ::wrock::arm_msg_<std::allocator<void> > arm_msg;

typedef boost::shared_ptr< ::wrock::arm_msg > arm_msgPtr;
typedef boost::shared_ptr< ::wrock::arm_msg const> arm_msgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::wrock::arm_msg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::wrock::arm_msg_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace wrock

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'sensor_msgs': ['/opt/ros/hydro/share/sensor_msgs/cmake/../msg'], 'wrock': ['/home/mike/catkin_ws/src/wrock/msg'], 'actionlib_msgs': ['/opt/ros/hydro/share/actionlib_msgs/cmake/../msg'], 'std_msgs': ['/opt/ros/hydro/share/std_msgs/cmake/../msg'], 'geometry_msgs': ['/opt/ros/hydro/share/geometry_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::wrock::arm_msg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::wrock::arm_msg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::wrock::arm_msg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::wrock::arm_msg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::wrock::arm_msg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::wrock::arm_msg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::wrock::arm_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "0125b561f6374b23eb39e79edf744818";
  }

  static const char* value(const ::wrock::arm_msg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x0125b561f6374b23ULL;
  static const uint64_t static_value2 = 0xeb39e79edf744818ULL;
};

template<class ContainerAllocator>
struct DataType< ::wrock::arm_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "wrock/arm_msg";
  }

  static const char* value(const ::wrock::arm_msg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::wrock::arm_msg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32 j1\n\
float32 j2\n\
float32 j3\n\
float32 j4\n\
float32 j5\n\
float32 j6\n\
float32 x\n\
float32 y\n\
float32 z\n\
float32 rx\n\
float32 ry\n\
float32 rz\n\
float32 vel\n\
float32 acc\n\
bool pose\n\
\n\
";
  }

  static const char* value(const ::wrock::arm_msg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::wrock::arm_msg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.j1);
      stream.next(m.j2);
      stream.next(m.j3);
      stream.next(m.j4);
      stream.next(m.j5);
      stream.next(m.j6);
      stream.next(m.x);
      stream.next(m.y);
      stream.next(m.z);
      stream.next(m.rx);
      stream.next(m.ry);
      stream.next(m.rz);
      stream.next(m.vel);
      stream.next(m.acc);
      stream.next(m.pose);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER;
  }; // struct arm_msg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::wrock::arm_msg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::wrock::arm_msg_<ContainerAllocator>& v)
  {
    s << indent << "j1: ";
    Printer<float>::stream(s, indent + "  ", v.j1);
    s << indent << "j2: ";
    Printer<float>::stream(s, indent + "  ", v.j2);
    s << indent << "j3: ";
    Printer<float>::stream(s, indent + "  ", v.j3);
    s << indent << "j4: ";
    Printer<float>::stream(s, indent + "  ", v.j4);
    s << indent << "j5: ";
    Printer<float>::stream(s, indent + "  ", v.j5);
    s << indent << "j6: ";
    Printer<float>::stream(s, indent + "  ", v.j6);
    s << indent << "x: ";
    Printer<float>::stream(s, indent + "  ", v.x);
    s << indent << "y: ";
    Printer<float>::stream(s, indent + "  ", v.y);
    s << indent << "z: ";
    Printer<float>::stream(s, indent + "  ", v.z);
    s << indent << "rx: ";
    Printer<float>::stream(s, indent + "  ", v.rx);
    s << indent << "ry: ";
    Printer<float>::stream(s, indent + "  ", v.ry);
    s << indent << "rz: ";
    Printer<float>::stream(s, indent + "  ", v.rz);
    s << indent << "vel: ";
    Printer<float>::stream(s, indent + "  ", v.vel);
    s << indent << "acc: ";
    Printer<float>::stream(s, indent + "  ", v.acc);
    s << indent << "pose: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.pose);
  }
};

} // namespace message_operations
} // namespace ros

#endif // WROCK_MESSAGE_ARM_MSG_H
